# 代码结构
## menu.h/menu.c设置
  - 设置菜单选项最大数量 `#define Number_Selection_Max`
  - 设置菜单清屏方式 `void Clear();`
  - 设置菜单刷新方式`void Refresh();`
  - 设置所有功能`void Function();`
  - 设置循环模式`void Loop();`
## SetMenu预处理
  - `Init();`
  - `Node *Main = New_Node();` <br>新建一个菜单节点
  - `Set_Name(Main, "The System");`<br>设置菜单名称
  - `Set_Message(Main, "2023 Datastructure");`<br>设置菜单信息
  - `Set_Number_Selection(Main, 4);`<br>设置选项数量
  - `Set_Selection(Main, "Show the message", 0, 1, 0);`<br>设置选项名称，选项顺序（从0开始），功能序号（用于通过Function调用），传递给Function的参数
  - `Set_Selection(Main, "Find the message", 1, 1, 1);`
  - `Set_Selection(Main, "exit", 2, 0, 0);`
  - `Set_Selection(Main, "egg", 3, 3, 0);`
  - ————
  - `Connect_Node(Main, SubMain_1, 0);`<br>连接主菜单与子菜单，设置子菜单在主菜单中的序号
  - ————
  - `Current_pNode = Main;`<br>设置当前菜单界面，即开始界面
## 菜单运行
- 通过`Loop()`函数进入循环
- 通过调用`Function()`函数运行功能

# 代码使用
## Current_pNode
- 这是实现当前菜单所有功能的入口
- Menu *`pMenu`
  - char *`Name_Menu`;
  - char *`Message`;
  - int `Number_Selection`;
  - char *`Name_Selection`[Number_Selection_Max];
  - int `Number_Function`[Number_Selection_Max];
  - int `Num_Function`[Number_Selection_Max];
- int `Current_Selection`
- struct `Node *Next`[Number_Selection_Max]
- struct `Node *Last`
## 显示信息
通过读取Current_pNode的信息来打印当前菜单，
- `Name_Menu`
- `Message`
- `Name_Selection[0]`
## 切换菜单
设置相应按键来对应Function  
```
case 1:
    {
        Current_pNode = Current_pNode->Next[Current_pNode->pMenu->Num_Function[Current_pNode->Current_Selection]];
        break;
    }
```
`case n` 即为`Number_Function[n];`对应的功能，它由`Current_pNode`引用，对应第 n 个菜单的功能序号，进入`Function()`中的`case`，可以在`case`中调用`Current_pNode`下的`Num_Function[n];`作为参数

例如，我设置了`Enter`为进入功能的按键，按下 `Enter`后调用`Function()`,此刻`Current_pNode`记录了我正处于哪一个菜单的哪一个选项，供`Function()`函数调用，可以让`Current_pNode`等于下一个或上一个菜单节点，这样下次显示信息时就是下一个或上一个的菜单，达到换页的效果，也可以进入某个功能，某个`run()`,实现其他自定义功能
